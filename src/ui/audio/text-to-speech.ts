//#region TStreamElementsVoiceID
/**
 * A string type that is a tested valid voice id for use with stream elements
 * text to speech
 */
export type TStreamElementsVoiceID =
  | "Filiz"
  | "Astrid"
  | "Tatyana"
  | "Maxim"
  | "Carmen"
  | "Ines"
  | "Cristiano"
  | "Vitoria"
  | "Ricardo"
  | "Maja"
  | "Jan"
  | "Jacek"
  | "Ewa"
  | "Ruben"
  | "Lotte"
  | "Liv"
  | "Seoyeon"
  | "Takumi"
  | "Mizuki"
  | "Giorgio"
  | "Carla"
  | "Bianca"
  | "Karl"
  | "Dora"
  | "Mathieu"
  | "Celine"
  | "Chantal"
  | "Penelope"
  | "Miguel"
  | "Mia"
  | "Enrique"
  | "Conchita"
  | "Geraint"
  | "Salli"
  | "Matthew"
  | "Kimberly"
  | "Kendra"
  | "Justin"
  | "Joey"
  | "Joanna"
  | "Ivy"
  | "Raveena"
  | "Aditi"
  | "Emma"
  | "Brian"
  | "Amy"
  | "Russell"
  | "Nicole"
  | "Vicki"
  | "Marlene"
  | "Hans"
  | "Naja"
  | "Mads"
  | "Gwyneth"
  | "Zhiyu"
  | "es-ES-Standard-A"
  | "it-IT-Standard-A"
  | "it-IT-Wavenet-A"
  | "ja-JP-Standard-A"
  | "ja-JP-Wavenet-A"
  | "ko-KR-Standard-A"
  | "ko-KR-Wavenet-A"
  | "pt-BR-Standard-A"
  | "tr-TR-Standard-A"
  | "sv-SE-Standard-A"
  | "nl-NL-Standard-A"
  | "nl-NL-Wavenet-A"
  | "en-US-Wavenet-A"
  | "en-US-Wavenet-B"
  | "en-US-Wavenet-C"
  | "en-US-Wavenet-D"
  | "en-US-Wavenet-E"
  | "en-US-Wavenet-F"
  | "en-GB-Standard-A"
  | "en-GB-Standard-B"
  | "en-GB-Standard-C"
  | "en-GB-Standard-D"
  | "en-GB-Wavenet-A"
  | "en-GB-Wavenet-B"
  | "en-GB-Wavenet-C"
  | "en-GB-Wavenet-D"
  | "en-US-Standard-B"
  | "en-US-Standard-C"
  | "en-US-Standard-D"
  | "en-US-Standard-E"
  | "de-DE-Standard-A"
  | "de-DE-Standard-B"
  | "de-DE-Wavenet-A"
  | "de-DE-Wavenet-B"
  | "de-DE-Wavenet-C"
  | "de-DE-Wavenet-D"
  | "en-AU-Standard-A"
  | "en-AU-Standard-B"
  | "en-AU-Wavenet-A"
  | "en-AU-Wavenet-B"
  | "en-AU-Wavenet-C"
  | "en-AU-Wavenet-D"
  | "en-AU-Standard-C"
  | "en-AU-Standard-D"
  | "fr-CA-Standard-A"
  | "fr-CA-Standard-B"
  | "fr-CA-Standard-C"
  | "fr-CA-Standard-D"
  | "fr-FR-Standard-C"
  | "fr-FR-Standard-D"
  | "fr-FR-Wavenet-A"
  | "fr-FR-Wavenet-B"
  | "fr-FR-Wavenet-C"
  | "fr-FR-Wavenet-D"
  | "da-DK-Wavenet-A"
  | "pl-PL-Wavenet-A"
  | "pl-PL-Wavenet-B"
  | "pl-PL-Wavenet-C"
  | "pl-PL-Wavenet-D"
  | "pt-PT-Wavenet-A"
  | "pt-PT-Wavenet-B"
  | "pt-PT-Wavenet-C"
  | "pt-PT-Wavenet-D"
  | "ru-RU-Wavenet-A"
  | "ru-RU-Wavenet-B"
  | "ru-RU-Wavenet-C"
  | "ru-RU-Wavenet-D"
  | "sk-SK-Wavenet-A"
  | "tr-TR-Wavenet-A"
  | "tr-TR-Wavenet-B"
  | "tr-TR-Wavenet-C"
  | "tr-TR-Wavenet-D"
  | "tr-TR-Wavenet-E"
  | "uk-UA-Wavenet-A"
  | "ar-XA-Wavenet-A"
  | "ar-XA-Wavenet-B"
  | "ar-XA-Wavenet-C"
  | "cs-CZ-Wavenet-A"
  | "nl-NL-Wavenet-B"
  | "nl-NL-Wavenet-C"
  | "nl-NL-Wavenet-D"
  | "nl-NL-Wavenet-E"
  | "en-IN-Wavenet-A"
  | "en-IN-Wavenet-B"
  | "en-IN-Wavenet-C"
  | "fil-PH-Wavenet-A"
  | "fi-FI-Wavenet-A"
  | "el-GR-Wavenet-A"
  | "hi-IN-Wavenet-A"
  | "hi-IN-Wavenet-B"
  | "hi-IN-Wavenet-C"
  | "hu-HU-Wavenet-A"
  | "id-ID-Wavenet-A"
  | "id-ID-Wavenet-B"
  | "id-ID-Wavenet-C"
  | "it-IT-Wavenet-B"
  | "it-IT-Wavenet-C"
  | "it-IT-Wavenet-D"
  | "ja-JP-Wavenet-B"
  | "ja-JP-Wavenet-C"
  | "ja-JP-Wavenet-D"
  | "cmn-CN-Wavenet-A"
  | "cmn-CN-Wavenet-B"
  | "cmn-CN-Wavenet-C"
  | "cmn-CN-Wavenet-D"
  | "nb-no-Wavenet-E"
  | "nb-no-Wavenet-A"
  | "nb-no-Wavenet-B"
  | "nb-no-Wavenet-C"
  | "nb-no-Wavenet-D"
  | "vi-VN-Wavenet-A"
  | "vi-VN-Wavenet-B"
  | "vi-VN-Wavenet-C"
  | "vi-VN-Wavenet-D"
  | "sr-rs-Standard-A"
  | "lv-lv-Standard-A"
  | "is-is-Standard-A"
  | "bg-bg-Standard-A"
  | "af-ZA-Standard-A"
  | "Tracy"
  | "Danny"
  | "Huihui"
  | "Yaoyao"
  | "Kangkang"
  | "HanHan"
  | "Zhiwei"
  | "Asaf"
  | "An"
  | "Stefanos"
  | "Filip"
  | "Ivan"
  | "Heidi"
  | "Herena"
  | "Kalpana"
  | "Hemant"
  | "Matej"
  | "Andika"
  | "Rizwan"
  | "Lado"
  | "Valluvar"
  | "Linda"
  | "Heather"
  | "Sean"
  | "Michael"
  | "Karsten"
  | "Guillaume"
  | "Pattara"
  | "Jakub"
  | "Szabolcs"
  | "Hoda"
  | "Naayf";
//#endregion

//#region TTS To URL
const DefaultStreamElementsVoiceID: TStreamElementsVoiceID = "Brian";

type TSoundEffectID = "SoundEffect";

/**
 * The text to speech service data
 * @param speaker the speaker of the text to speech
 * @param buffer the audio buffer of the text to speech
 */
export type TBufferRequestData = {
  speaker: TStreamElementsVoiceID | TSoundEffectID;
  url: string;
};

export type TPopulatedAudioBufferData = TBufferRequestData & {
  arrayBuffer: ArrayBuffer;
};

/**
 * Options for the text to speech service
 * @param voiceID the default voice to use for the text to speech
 * @param availableVoices the available voices to use "other voices" command
 * @param a map
 */
export type TTextToSpeechOptions = {
  voiceID?: TStreamElementsVoiceID;
  commandIdentifier?: string;
  availableVoices?: TStreamElementsVoiceID[];
  soundClipURLs?: { [key: string]: string };
};

const DefaultTTSCommandIdentifier: string = "$";

function GetStreamElementsTTSURL(
  text: string,
  voiceID: TStreamElementsVoiceID
): string {
  return `https://api.streamelements.com/kappa/v2/speech?voice=${voiceID}&text=${encodeURIComponent(
    text
  )}`;
}

export function ParseTextToSpeechText(
  text: string,
  options?: TTextToSpeechOptions
): TBufferRequestData[] {
  if (!text || text.length < 1) return [];

  let voiceID: TStreamElementsVoiceID =
    options?.voiceID ?? DefaultStreamElementsVoiceID;
  const commandIdentifier: string =
    options?.commandIdentifier ?? DefaultTTSCommandIdentifier;

  const segments: string[] = text.split(commandIdentifier);
  const bufferRequests: TBufferRequestData[] = [];

  segments.forEach((segment, index) => {
    if (index !== 0) {
      if (segment.length < 1) return;
      for (const voice of options?.availableVoices ?? []) {
        if (segment.startsWith(voice)) {
          voiceID = voice;
          segment = segment.substring(voice.length);
        }
      }

      if (segment.length < 1) return;
      for (const soundClip in options?.soundClipURLs ?? {}) {
        if (segment.startsWith(soundClip)) {
          bufferRequests.push({
            speaker: "SoundEffect",
            url: options?.soundClipURLs?.[soundClip] ?? "",
          });
          segment = segment.substring(soundClip.length);
        }
      }
    }

    if (segment.length < 1) return;
    bufferRequests.push({
      speaker: voiceID,
      url: GetStreamElementsTTSURL(segment, voiceID),
    });
  });

  return bufferRequests;
}
//#endregion

//#region Fetch URL Buffer
/**
 * Options for FilterAudioBuffer
 * @param normalize if true, the audio buffer will be normalized to the loudest
 * point in the buffer
 * @param downmix_to_mono if true, the audio buffer will be downmixed to mono
 */
export type TFilterAudioBufferOptions = {
  normalize?: boolean;
  downmix_to_mono?: boolean;
  channel_count?: number;
  sample_rate?: number;
};

/**
 * Will receive an audio buffer and normalize it to the loudest point in the
 * buffer
 * @param audioBuffer the audio buffer you wish to normalize the audio of
 * @param audioContext optional, assigning an audio context here prevents the
 * creation of a new audio context (try to provide yours)
 * @returns the normalized audio buffer based on the loudest point in the audio
 * buffer
 */
export function FilterAudioBuffer(
  audioContext: BaseAudioContext,
  audioBuffer: AudioBuffer,
  options?: TFilterAudioBufferOptions
): AudioBuffer {
  if (!options) return audioBuffer;

  /**
   *  make channel data available
   * ! NOTE: these are references to the original data, changes will affect
   * ! the original audio buffer
   */
  const channelData: Float32Array[] = [];
  for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
    channelData.push(audioBuffer.getChannelData(channel));
  }

  /** get max amplitude for use with normalization */
  let maxAmplitude = 1;
  if (options.normalize) {
    maxAmplitude = 0;
    for (let c = 0; c < channelData.length; c++) {
      for (let i = 0; i < channelData[c].length; i++) {
        const amplitude = Math.abs(channelData[c][i]);
        if (amplitude > maxAmplitude) {
          maxAmplitude = amplitude;
        }
      }
    }
  }
  const gain = options.normalize ? maxAmplitude / maxAmplitude : 1;

  /** create a new audio buffer */
  const newBuffer = audioContext.createBuffer(
    options.downmix_to_mono ? 1 : audioBuffer.numberOfChannels,
    audioBuffer.length,
    audioBuffer.sampleRate
  );

  const newChannelData: Float32Array[] = [];
  for (let channel = 0; channel < newBuffer.numberOfChannels; channel++) {
    newChannelData.push(newBuffer.getChannelData(channel));
  }

  /** assign new data to new buffer
   * normalize function is encoded to gain variable
   * downmix_to_mono is handled by the loop
   */
  for (let i = 0; i < channelData[0].length; i++) {
    for (let c = 0; c < channelData.length; c++) {
      if (options.downmix_to_mono) {
        newChannelData[0][i] += (channelData[c][i] * gain) / channelData.length;
      } else {
        newChannelData[c][i] = channelData[c][i] * gain;
      }
    }
  }

  return newBuffer;
}

/**
 *
 * @param audioContext
 * @param datas
 * @param options
 * @returns
 */
export function FetchAndPopulateBuffers(
  datas: TBufferRequestData[]
): Promise<TPopulatedAudioBufferData[]> {
  const promises = datas.map(
    async (data): Promise<TPopulatedAudioBufferData> => {
      const response: Response = await fetch(data.url);
      const arrayBuffer: ArrayBuffer = await response.arrayBuffer();
      return {
        ...data,
        arrayBuffer: arrayBuffer,
      };
    }
  );

  return Promise.all(promises);
}
//#endregion
